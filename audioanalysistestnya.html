<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Audio Waveform Viewer</title>

<style>
    body {
        background: #0e0e0e;
        color: #eee;
        font-family: system-ui, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
    }

    .controls {
        margin-bottom: 10px;
        display: flex;
        gap: 10px;
        align-items: center;
    }

    button {
        padding: 6px 12px;
        border: none;
        border-radius: 6px;
        background: #1f1f1f;
        color: #fff;
        cursor: pointer;
    }

    button:hover {
        background: #333;
    }

    input[type="file"] {
        color: #aaa;
    }

    #time {
        font-variant-numeric: tabular-nums;
        min-width: 120px;
        text-align: right;
    }

    canvas {
        background: #121212;
        border-radius: 10px;
        cursor: grab;
    }

    canvas:active {
        cursor: grabbing;
    }
</style>
</head>

<body>

<div class="controls">
    <input type="file" id="fileInput" accept="audio/*">
    <button id="playBtn">Play</button>
    <div id="time">0 ms</div>
</div>

<canvas id="waveform" width="900" height="200"></canvas>

<script>
const canvas = document.getElementById("waveform");
const ctx = canvas.getContext("2d");

const fileInput = document.getElementById("fileInput");
const playBtn = document.getElementById("playBtn");
const timeLabel = document.getElementById("time");

let audioCtx;
let audioBuffer;
let sourceNode;
let gainNode;

let isPlaying = false;
let startTime = 0;
let pauseOffset = 0;

const linesPerSecond = 400;
let waveformData = [];
let scrollTime = 0;

let dragging = false;
let lastX = 0;

// ---------- LOAD AUDIO ----------
fileInput.addEventListener("change", async e => {
    const file = e.target.files[0];
    if (!file) return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const buffer = await file.arrayBuffer();
    audioBuffer = await audioCtx.decodeAudioData(buffer);

    generateWaveform();
    pauseOffset = 0;
    scrollTime = 0;
    updateTimeLabel();
    draw();
});

// ---------- WAVEFORM (CLEAN & NORMALIZED) ----------
function generateWaveform() {
    const channel = audioBuffer.getChannelData(0);
    const totalLines = Math.floor(audioBuffer.duration * linesPerSecond);
    const samplesPerLine = Math.floor(channel.length / totalLines);

    waveformData = new Array(totalLines);
    let maxAmp = 0;

    for (let i = 0; i < totalLines; i++) {
        let sum = 0;
        const start = i * samplesPerLine;
        for (let j = 0; j < samplesPerLine; j++) {
            sum += Math.abs(channel[start + j] || 0);
        }
        const avg = sum / samplesPerLine;
        waveformData[i] = avg;
        if (avg > maxAmp) maxAmp = avg;
    }

    // Normalize once (prevents visual layering)
    for (let i = 0; i < waveformData.length; i++) {
        waveformData[i] /= maxAmp || 1;
    }
}

// ---------- PLAY / PAUSE (GAIN SAFE) ----------
playBtn.addEventListener("click", () => {
    if (!audioBuffer) return;

    if (!isPlaying) {
        sourceNode = audioCtx.createBufferSource();
        sourceNode.buffer = audioBuffer;

        gainNode = audioCtx.createGain();
        gainNode.gain.value = 1.0; // ðŸ”’ no amplification

        sourceNode.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        startTime = audioCtx.currentTime - pauseOffset;
        sourceNode.start(0, pauseOffset);

        isPlaying = true;
        playBtn.textContent = "Pause";

        sourceNode.onended = () => {
            isPlaying = false;
            pauseOffset = 0;
            playBtn.textContent = "Play";
            updateTimeLabel();
        };

        requestAnimationFrame(update);
    } else {
        sourceNode.stop();
        pauseOffset = audioCtx.currentTime - startTime;
        isPlaying = false;
        playBtn.textContent = "Play";
        updateTimeLabel();
    }
});

// ---------- TIME ----------
function updateTimeLabel() {
    const ms = pauseOffset * 1000;
    const fps = ms * 0.06;
    timeLabel.textContent = `${Math.floor(pauseOffset * 1000)} ms, frame ${fps.toFixed(1)}`;
}

// ---------- DRAW (SINGLE LAYER) ----------
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const mid = canvas.height / 2;

    const startLine = Math.floor(scrollTime * linesPerSecond);
    const linesOnScreen = canvas.width;

    ctx.strokeStyle = "#39C5BB";
    ctx.lineWidth = 1;
    ctx.beginPath();

    for (let x = 0; x < linesOnScreen; x++) {
        const index = startLine + x;
        if (index < 0 || index >= waveformData.length) continue;

        const amp = waveformData[index] * mid;
        ctx.moveTo(x, mid - amp);
        ctx.lineTo(x, mid + amp);
    }

    ctx.stroke();

    // Playhead
    ctx.strokeStyle = "#ff4c4c";
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, canvas.height);
    ctx.stroke();
}

// ---------- UPDATE LOOP ----------
function update() {
    if (!isPlaying) return;

    pauseOffset = audioCtx.currentTime - startTime;
    scrollTime = pauseOffset;
    updateTimeLabel();
    draw();

    requestAnimationFrame(update);
}

// ---------- DRAG SCRUB ----------
canvas.addEventListener("mousedown", e => {
    dragging = true;
    lastX = e.clientX;
});

window.addEventListener("mouseup", () => dragging = false);

window.addEventListener("mousemove", e => {
    if (!dragging || !audioBuffer) return;

    const dx = e.clientX - lastX;
    lastX = e.clientX;

    scrollTime -= dx / linesPerSecond;
    scrollTime = Math.max(0, Math.min(audioBuffer.duration, scrollTime));
    pauseOffset = scrollTime;

    if (isPlaying) {
        sourceNode.stop();
        isPlaying = false;
        playBtn.textContent = "Play";
    }

    updateTimeLabel();
    draw();
});
</script>

</body>
</html>